{
  "hash": "711473541debdaa2819f5287d741cb57",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Speeding up your R scripts\"\ntitle-block-banner: darkolivegreen\nformat: \n  html:\n    toc: true\n    toc-location: left\n    toc-depth: 4\neditor: visual\nauthor: \n  name: \n    given: Florian\n    family: Lecorvaisier\n  degrees: \n    - PhD\n    - MSc\n    - BSc\n  orcid: 0000-0001-8201-5350\n  email: florian.lecorvaisier@gmail.com\n  url: https://flolecorvaisier.github.io\ndate: \"2026-01-25\"\ndate-modified: \"2026-01-25\"\nembed-resources: true\nbibliography: references.bib\ncategories: [tips and tricks]\nimage: \"thumbnail.jpg\"\ndescription: \"In this post, I will share a few tips on how to speed up the execution of your R scripts.\"\nmainfont: Ubuntu\n---\n\n## Introduction\n\nWhy speeding up your code? If it works and is readable, why bothering optimizing the execution time? For most scripts, even it is comprises hundreds of lines of code, they will execute in a matter of seconds maximum. Generally, rendering figures is the most time-consuming part of R scripts, and even this is not that long.\n\nNow, some people – me, for example – are working on code scripts that may take dozen of minutes or even hours to execute. For example, during my PhD, I used `jagsUI` to run MCMC simulations that took a few minutes to run, and had to run *a lot* of these simulations. Now, at the time I write this post, I am working on an individual-based model of the dynamics of African swine fever in a population of wild boars. In this model, what happens to *each boar* is modeled *each day*. Thus, there are a lot of things at work and it takes some time to run one simulation (sometimes, more than two hours, and the model is not finished yet), and reducing the computing time is interesting for me for multiple reasons:\n\n-   my results are available sooner;\n\n-   less computing time means less resources used;\n\n-   I work on a shared computing cluster, so the less time my simulations run, the better for everyone wanting to use the cluster.\n\nFor all these reasons, I spent (and continue to spend) quite some time trying to speed up my code. I found multiple tricks, some well known, some more obscure, some useful for everyone and some useful only in specific cases. Here, I would like to share some of these tricks.\n\n## General tips\n\n### Sequences\n\nIn R, there are multiple ways to produce a sequence of numbers. The easiest one is to create a vector with the `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n```\n:::\n\n\nOn the example above, we have a regular sequence of integers from one to ten. In this specific case, this is not the optimal way to create the sequence, and most of R users would rather use\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx2 = seq(1, 10, 1)\n```\n:::\n\n\nor, even simpler,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx3 = 1:10\n```\n:::\n\n\nNow, are these two lines of code identical? They produce the same results, as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx2 == x3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n\nSo you could think that both techniques could be used interchangeably. And you would not be wrong. But try running these functions a lot of times, and you will see strong differences appear. For the sake of the example, I will use larger sequences sizes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(\n  for (i in 1:1e4) {\n    seq(1, 1e5, 1)\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n       4.57        0.69        5.25 \n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time(\n  for (i in 1:1e8) {\n    1:1e5\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n       2.61        0.01        2.63 \n```\n\n\n:::\n:::\n\n\nIn the code above, I asked 10,000 times for a sequence ranging from one to 100,000 using `seq()`. On my PC, R delivered in 5.25 seconds. Then I asked 100,000,000 times for the same sequence, but using the simpler notation, and it delivered in less than half the time (for a much higher number of sequences).\n\nObviously, you will probably rarely need to ask for this many sequences, and my example only works for consecutive sequences of integers[^1], but hey it may help someone out there.\n\n[^1]: You can transform the outputs of the sequence, for example `1:1e5 / 2` but doing so rises the execution time, and the amount of time lost is linked to the complexity of the transformation.\n\n### Loops\n\nThere is a \"legend\" among R users that using `for` loops slows down your code a lot, and that you should rather use `*apply()` functions to make your code run faster. I would like to bring some nuance to that. Consider the example below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 = x2 = 1:1e6\n\nsystem.time(\n  for (i in 1:length(x1)) {\n    x1[i] = x1[i] * 2\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n       0.03        0.00        0.03 \n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time(\n  {x2 = sapply(x2, function(i) i * 2)}\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n       0.69        0.00        0.69 \n```\n\n\n:::\n:::\n\n\nIn this case, I first used a `for` loop to multiply by two the values in vector `x1`. Then, I did the exact same operation with vector `x2` but using the `sapply()` function. We see below that the results are exactly the same, but using the `for` loop was 20 times faster!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(x1 == x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   TRUE \n1000000 \n```\n\n\n:::\n:::\n\n\nBut there are indeed cases where using a function from the `*apply()` family really speeds up your code. In the example below, I create a data frame with 10,000,000 values (`df$x`) distributed in 1,000 categories (`df$y`). Then, for each category, I calculate the average value of `df$x` using either a `for` loop or the `tapply()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\ndf = data.frame(\n  x = runif(1e7),\n  y = sample(1:1e3, size = 1e5, replace = T)\n)\n\nsystem.time(\n  for (i in unique(df$y)) {\n    mean(df$x[df$y == i])\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n      18.82        3.69       22.61 \n```\n\n\n:::\n\n```{.r .cell-code}\nsystem.time(\n  tapply(df$x, df$y, mean)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutilisateur     système      écoulé \n       0.26        0.09        0.36 \n```\n\n\n:::\n:::\n\n\nWe can see using the `tapply()` function is way, *way* faster than using the loop. So, in this case, I would strongly encourage using the `tapply()` function, especially if you must it on really large data sets.\n\nSo, in the end, when should you use a loop and when should you use a `*apply()` function? I do not know! It seems to depend on what exactly you are doing, so I encourage you to try both approaches if you see your code getting slower.\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.1 (2025-06-13 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 26200)\n\nMatrix products: default\n  LAPACK version 3.12.1\n\nlocale:\n[1] LC_COLLATE=French_France.utf8  LC_CTYPE=French_France.utf8   \n[3] LC_MONETARY=French_France.utf8 LC_NUMERIC=C                  \n[5] LC_TIME=French_France.utf8    \n\ntime zone: Europe/Paris\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.5.1    fastmap_1.2.0     cli_3.6.5        \n [5] tools_4.5.1       htmltools_0.5.8.1 rstudioapi_0.17.1 yaml_2.3.10      \n [9] rmarkdown_2.29    knitr_1.50        jsonlite_2.0.0    xfun_0.53        \n[13] digest_0.6.37     rlang_1.1.6       evaluate_1.0.5   \n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}